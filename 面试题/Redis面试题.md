#### Q1. 单线程的Redis为什么这么快?
官方给出的速度是: 10万/秒;

原因如下:
- **纯内存操作:** Redis是完全基于内存的，所以读写效率非常的高, 当然Redis存在持久化操作， 在持久化操作都是fork子进程和利用linux系统的页缓存技术来完成，并不会影响redis的性能;
- **单线程操作:** 单线程并不是坏事，单线程可以避免了频繁的上下文切换，频繁的上下文切换也会影响性能的;
- **合理高效的数据结构 采用了非阻塞 I/O 多路复用机制：** 多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

#### Q2. I/O 多路复用是什么?
```
```

#### Q3. Redis 常用的数据结构有哪些?
- string:
- hash:
- list:
- set:
- zset:

#### Q4. 如何解决 Redis 缓存穿透和缓存雪崩问题？
**缓存雪崩：** 由于缓存层承载着大量请求，有效地 保护了存储层，但是如果缓存层由于某些原因不能提供服务，比如 Redis 节点挂掉了，热点 key 全部失效了，在这些情况下，所有的请求都会直接请求到数据库，可能会造成数据库宕机的情况。

预防和解决缓存雪崩问题，可以从以下三个方面进行着手：

- 使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉
- 缓存时间不一致： 给缓存的失效时间，加上一个随机值，避免集体失效
- 限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务

**缓存穿透：** 缓存穿透是指查询一个根本不存在的数据，这样的数据肯定不在缓存中，这会导致请求全部落到数据库上，有可能出现数据库宕机的情况。

**缓存击穿：** 缓存在同一时刻大面积失效，查询全部落到了数据库上， 导致数据库的压力剧增， 甚至压垮数据库。

预防和解决缓存穿透问题，可以考虑以下两种方法：
- **缓存空对象：** 将空值缓存起来，但是这样就有一个问题，大量无效的空值将占用空间，非常浪费。
- **缓存击穿：** 给缓存设置随机的过期时间，避免在同一时刻缓存的大量失效。
- **布隆过滤器拦截：** 将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回。布隆过滤器有一定的误判，所以需要你的业务允许一定的容错性。


#### Q5.哨兵模式会不会更新新的ip,此时你的代码里面连接的redis要不要跟新配置?哨兵模式下,主服务器挂掉,切换到从服务器?
