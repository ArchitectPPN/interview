#### Q1. 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？
- 如果表的类型是MyISAM，那么是18.因为MyISAM会把自己增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。
- 如果表的类型是InnoDB，那么是15.InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。

#### Q2. 如何区分FLOAT和DOUBLE？
以下是FLOAT和DOUBLE的区别：

- 浮点数以8位精度存储在FLOAT中，并且有四个字节。
- 浮点数存储在DOUBLE中，精度为18位，有八个字节。

#### Q3. 请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？
SQL标准定义的四个隔离级别为：

- read uncommited ：读到未提交数据

Read Uncommitted（读取未提交内容）在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

- read committed：脏读，不可重复读

Read Committed（读取提交内容）这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

- repeatable read：可重读

 Repeatable Read（可重读）这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。
 
- serializable ：串行事物 

Serializable（可串行化）这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 

对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在： 
- 1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。 
- 2、非重复读（nonrepeatableread）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。 
- 3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。

#### Q4. MySQL中char、varchar和text的区别
它们的存储方式和数据的检索方式都不一样;

数据的检索效率是：char > varchar > text;

空间占用方面，就要具体情况具体分析了;

**char:** 存储定长数据很方便，CHAR字段上的索引效率级高，必须在括号里定义长度，可以有默认值，比如定义char(10)，那么不论你存储的数据是否达到了10个字符，都要占去10个字符的空间（自动用空格填充），且在检索的时候后面的空格会隐藏掉，所以检索出来的数据需要记得用什么trim之类的函数去过滤空格。

**vachar:** 存储变长数据，但存储效率没有CHAR高，必须在括号里定义长度，可以有默认值。保存数据的时候，不进行空格自动填充，而且如果数据存在空格时，当值保存和检索时尾部的空格仍会保留。另外，varchar类型的实际长度是它的值的实际长度+1，这一个字节用于保存实际使用了多大的长度。

**text:** 存储可变长度的非Unicode数据，最大长度为2^31-1个字符。text列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。

**关于存储空间:** 在使用UTF8字符集时, 大概是英文/数字/标点符号占用一个字节; 中文占用三个字节;

**结论:**  

- 经常变化的字段使用varchar, 例如: 用户名/昵称等;
- 知道固定长度的使用varcahr, 例如: 手机号/用户的UUID;
- 尽量用varchar, 节省存储空间;
- 超过255字节的只能使用varchar或者text;
- 能够用数字类型的字段尽量选择数字类型而不用字符串类型的（电话号码），这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

#### Q5. 索引设计原则以及常见索引的区别

- **唯一性索引:** 索引列必须唯一, 且允许为空;
- **普通索引:** 普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREcolumn=）或排序条件（ORDERBYcolumn）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。
- **主键索引:** 用于标识唯一的一条记录, 不允许有空值;
- **联合索引:** 为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。

#### Q6. 主键索引和唯一索引的区别:

- 主键是一种约束,唯一索引是一种索引, 唯一索引并不一定是主键索引;
- 主键创建后一定包含一个唯一性索引, 唯一索引并不一定就是主键;
- 唯一索引列允许空值, 而主键列不允许空值;
- 主键在创建时, 已经默认为非空值+唯一索引了;
- 主键可以被其他表引用为外键, 而唯一索引不能;
- 一个表最多可以创建一个主键索引, 但是可以创建多个唯一索引;
- 主键和唯一都可以有多列;
- 主键更适合那些不容易更改的唯一标识, 如自动递增和身份证号等;
- 在 RBO 模式下, 主键的执行计划优先级要高于唯一索引. 两者都可以增加查询速度;

>注: 唯一索引相当于一本书的目录, 主键索引相当于一本书的目录;

#### Q7. 可以使用多少列创建索引？

任何标准表最多可以创建16个索引列。

#### Q8. MySQL 哪些情况不使用索引?


#### Q9. 为什么主键索引查询比普通索引性能高?


#### Q10. 更新操作中，mysql的读写分离架构，怎么解决数据数据不一致问题?


#### Q11. innodb是怎么实现mvcc机制的?


#### Q12. 为什么MySQL不推荐使用uuid作为主键？
**使用自增主键:**

自增的主键的值是顺序的，所以Innodb把每一条记录都存储在一条记录的后面。当达到页面的最大填充因子时候(innodb默认的最大填充因子是页大小的15/16，会留出1/16的空间留作以后的修改)：

①下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费

②新插入的行一定会在原有的最大数据行下一行，mysql定位和寻址很快，不会为计算新行的位置而做出额外的消耗

③减少了页分裂和碎片的产生

**使用uuid的索引内部结构:**
因为uuid相对顺序的自增id来说是毫无规律可言的，新行的值不一定要比之前的主键的值要大，所以innodb无法做到总是把新行插入到索引的最后，而是需要为新行寻找新的合适的位置从而来分配新的空间。

这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致以下的问题：

①写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO

②因为写入是乱序的，innodb不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据，一次插入最少需要修改三个页以上

③由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片

在把随机值（uuid和雪花id）载入到聚簇索引(innodb默认的索引类型)以后，有时候会需要做一次OPTIMEIZE TABLE来重建表并优化页的填充，这将又需要一定的时间消耗。

结论：使用innodb应该尽可能的按主键的自增顺序插入，并且尽可能使用单调的增加的聚簇键的值来插入新行

**使用自增id的缺点:**
那么使用自增的id就完全没有坏处了吗？并不是，自增id也会存在以下几点问题：

①别人一旦爬取你的数据库，就可以根据数据库的自增id获取到你的业务增长信息，很容易分析出你的经营情况

②对于高并发的负载，innodb在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争

③Auto_Increment锁机制会造成自增锁的抢夺，有一定的性能损失

`附：Auto_increment的锁争抢问题，如果要改善需要调优innodb_autoinc_lock_mode的配置`


#### Q13. 唯一索引比普通索引快吗, 为什么?
唯一索引不一定比普通索引更快, 还可能更慢;

- 查询时, 在未使用limit 1 的情况下, 在匹配到一条数据后, 唯一索引即返回, 普通索引会继续匹配下一条数据, 返现不匹配之后返回. 如此看来唯一索引减少了一次匹配, 但实际上这个消耗微乎其微.
- 更新时, 这个情况就比较复杂了. 普通索引将记录放到change buffer中语句就执行完毕了, 而对唯一索引而言, 他必须要校验唯一性, 因此, 必须将数据页读入内存确定有没有冲突, 然后才能继续操作. 对于写多读少的情况下, 普通索引利用change buffer有效减少了对磁盘的访问次数, 因此普通索引性能要高于唯一索引. 

#### Q14. 如何优化数据库?
数据库的优化可以从四个方面来优化

- **从结构层:** web服务器采用负载均衡服务器,mysql服务器采用主从复制,读写分离
- **从储存层:** 采用合适的存储引擎,采用三范式
- **从设计层:** 采用分区分表,索引,表的字段采用合适的字段属性,适当的采用逆范式,开启mysql缓存
- **SQL语句层:** 结果一样的情况下,采用效率高,速度快节省资源的sql语句执行

#### Q15.union 和union all的区别
- union会对结果集进行处理排除掉相同的结果
- union all 不会对结果集进行处理，不会处理掉相同的结果

#### Q16. 乐观锁和悲观锁
- 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。
- 悲观锁每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
- 两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

#### Q17. drop、truncate和delete的区别
- 执行速度 drop > truncate > delete
- **delete**一行一行删除，truncate 删除表全部数据，drop 连表数据和表结构一起删除
- **delete** 是 DML 语句，没提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚
- 有**FOREIGN KEY** 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句
- **delete**删除行会出现id不联系，truncate是id重新开始

#### Q18. 水平分区和垂直分区和读写分离
- 水平分区（Horizontal Partitioning） 这种形式分区是对表的行进行分区，通过这样的方式不同分组里面的物理列分割的数据集得以组合，从而进行个体分割（单分区）或集体分割（1个或多个分区）。所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。
- - 举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。（注：这里具体使用的分区方式我们后面再说，可以先说一点，一定要通过某个属性列来分割，譬如这里使用的列就是年份）
- 垂直分区（Vertical Partitioning） 这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。
举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。
- 读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。

#### Q19. explian type(重要)
访问类型，非常滴重要，结果从好到坏依次是:
```
system > const > eq_ref > ref(优秀线) > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range(合格线) > index > ALL
```
- **system：** 表中仅有一行（=系统表）这是const联结类型的一个特例。
- **const：** 表示通过索引一次就找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以如果将主键置于where列表中，mysql能将该查询转换为一个常量
- **eq_ref:** 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于唯一索引或者主键扫描
- **ref:** 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体
- **range:** 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是where语句中出现了between,in等范围的查询。这种范围扫描索引扫描比全表扫描要好，因为它开始于索引的某一个点，而结束另一个点，不用全表扫描
- **index:** index 与all区别为index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多。
- **all：** 遍历全表以找到匹配的行
#### Q20. 如何随机的取一条Mysql数据?
```
1. ORDER BY RAND()
写法：SELECT * FROM 表A ORDER BY RAND() LIMIT 1
rand()放在ORDER BY 子句中会被执行多次，自然效率极低，mysql官方不提倡;

2. max(id) * rand()
写法：SELECT * FROM 表A  WHERE id >= (SELECT FLOOR( MAX(id) * RAND()) FROM 表A ) ORDER BY id LIMIT 1;

3. max(id) * rand() + join
写法：select id from table 表A join (select round(rand()*(select max(id ) from table)) as idd) as 表B on 表A.id>表B.idd limit 1;

```


#### Q21. MySql中Group By、Order By、Having、Limit 执行顺序


#### Q22. Mysql中int(3)和int(11)有什么区别？
mysql手册是这样写的：MySQL还支持选择在该类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。该可选显示宽度规定用于显示宽度小于指定的列宽度的值时从左侧填满宽度。显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。

简答来说： 控制不满足指定长度时，数字前面填充0的个数。

最后总结：虽然int设置长度值的意义不大，但是在于统一规范和数据库可读性的角度上来讲，建议还是应该设置一个合理范围的值的。

#### Q23. MySql库建表建议
- 尽量不要在一个数据库中使用不同的字符集, 可能会导致索引失效， 使用CONVERT(字段名 using utf8)。 


#### Q24.


#### Q25.


#### Q26.


#### Q27.


#### Q28.


#### Q29.


#### Q30.


#### Q31.


#### Q32.


#### Q33.


#### Q34.


#### Q35.


#### Q36.


#### Q37.


#### Q38.


#### Q39.


#### Q40.


#### Q41.


#### Q42.


#### Q43.


#### Q44.


#### Q45.


#### Q46.


#### Q47.


#### Q48.


#### Q49.


#### Q50.


#### Q51.


#### Q52.


#### Q53.


#### Q54.


#### Q55.


#### Q56.


#### Q57.


#### Q58.


#### Q59.


#### Q60.


#### Q61.


#### Q62.


#### Q63.


#### Q64.


#### Q65.


#### Q66.


#### Q67.


#### Q68.


#### Q69.


#### Q70.


#### Q71.


#### Q72.


#### Q73.


#### Q74.


#### Q75.


#### Q76.


#### Q77.


#### Q78.


#### Q79.


#### Q80.


#### Q81.


#### Q82.


#### Q83.


#### Q84.


#### Q85.


#### Q86.


#### Q87.


#### Q88.


#### Q89.


#### Q90.


#### Q91.


#### Q92.


#### Q93.


#### Q94.


#### Q95.


#### Q96.


#### Q97.


#### Q98.


#### Q99.


#### Q100.


#### Q101.


#### Q102.


#### Q103.


#### Q104.


#### Q105.


#### Q106.


#### Q107.


#### Q108.


#### Q109.


#### Q110.


#### Q111.


#### Q112.


#### Q113.


#### Q114.


#### Q115.


#### Q116.


#### Q117.


#### Q118.


#### Q119.


#### Q120.


#### Q121.


#### Q122.


#### Q123.


#### Q124.


#### Q125.


#### Q126.


#### Q127.


#### Q128.


#### Q129.


#### Q130.


#### Q131.


#### Q132.


#### Q133.


#### Q134.


#### Q135.


#### Q136.


#### Q137.


#### Q138.


#### Q139.


#### Q140.


#### Q141.


#### Q142.


#### Q143.


#### Q144.


#### Q145.


#### Q146.


#### Q147.


#### Q148.


#### Q149.


#### Q150.


#### Q151.


#### Q152.


#### Q153.


#### Q154.


#### Q155.


#### Q156.


#### Q157.


#### Q158.


#### Q159.


#### Q160.


#### Q161.


#### Q162.


#### Q163.


#### Q164.


#### Q165.


#### Q166.


#### Q167.


#### Q168.


#### Q169.


#### Q170.


#### Q171.


#### Q172.


#### Q173.


#### Q174.


#### Q175.


#### Q176.


#### Q177.


#### Q178.


#### Q179.


#### Q180.


#### Q181.


#### Q182.


#### Q183.


#### Q184.


#### Q185.


#### Q186.


#### Q187.


#### Q188.


#### Q189.


#### Q190.


#### Q191.


#### Q192.


#### Q193.


#### Q194.


#### Q195.


#### Q196.


#### Q197.


#### Q198.


#### Q199.


#### Q200.


#### Q201.


#### Q202.


#### Q203.


#### Q204.


#### Q205.


#### Q206.


#### Q207.


#### Q208.


#### Q209.


#### Q210.


#### Q211.


#### Q212.


#### Q213.


#### Q214.


#### Q215.


#### Q216.


#### Q217.


#### Q218.


#### Q219.


#### Q220.


#### Q221.


#### Q222.


#### Q223.


#### Q224.


#### Q225.


#### Q226.


#### Q227.


#### Q228.


#### Q229.


#### Q230.


#### Q231.


#### Q232.


#### Q233.


#### Q234.


#### Q235.


#### Q236.


#### Q237.


#### Q238.


#### Q239.


#### Q240.


#### Q241.


#### Q242.


#### Q243.


#### Q244.


#### Q245.


#### Q246.


#### Q247.


#### Q248.


#### Q249.


#### Q250.


#### Q251.


#### Q252.


#### Q253.


#### Q254.


#### Q255.


#### Q256.


#### Q257.


#### Q258.


#### Q259.


#### Q260.


#### Q261.


#### Q262.


#### Q263.


#### Q264.


#### Q265.


#### Q266.


#### Q267.


#### Q268.


#### Q269.


#### Q270.


#### Q271.


#### Q272.


#### Q273.


#### Q274.


#### Q275.


#### Q276.


#### Q277.


#### Q278.


#### Q279.


#### Q280.


#### Q281.


#### Q282.


#### Q283.


#### Q284.


#### Q285.


#### Q286.


#### Q287.


#### Q288.


#### Q289.


#### Q290.


#### Q291.


#### Q292.


#### Q293.


#### Q294.


#### Q295.


#### Q296.


#### Q297.


#### Q298.


#### Q299.


#### Q300.


#### Q301.


#### Q302.


#### Q303.


#### Q304.


#### Q305.


#### Q306.


#### Q307.


#### Q308.


#### Q309.


#### Q310.


#### Q311.


#### Q312.


#### Q313.


#### Q314.


#### Q315.


#### Q316.


#### Q317.


#### Q318.


#### Q319.


#### Q320.


#### Q321.


#### Q322.


#### Q323.


#### Q324.


#### Q325.


#### Q326.


#### Q327.


#### Q328.


#### Q329.


#### Q330.


#### Q331.


#### Q332.


#### Q333.


#### Q334.


#### Q335.


#### Q336.


#### Q337.


#### Q338.


#### Q339.


#### Q340.


#### Q341.


#### Q342.


#### Q343.


#### Q344.


#### Q345.


#### Q346.


#### Q347.


#### Q348.


#### Q349.


#### Q350.


#### Q351.


#### Q352.


#### Q353.


#### Q354.


#### Q355.


#### Q356.


#### Q357.


#### Q358.


#### Q359.


#### Q360.


#### Q361.


#### Q362.


#### Q363.


#### Q364.


#### Q365.


#### Q366.


#### Q367.


#### Q368.


#### Q369.


#### Q370.


#### Q371.


#### Q372.


#### Q373.


#### Q374.


#### Q375.


#### Q376.


#### Q377.


#### Q378.


#### Q379.


#### Q380.


#### Q381.


#### Q382.


#### Q383.


#### Q384.


#### Q385.


#### Q386.


#### Q387.


#### Q388.


#### Q389.


#### Q390.


#### Q391.


#### Q392.


#### Q393.


#### Q394.


#### Q395.


#### Q396.


#### Q397.


#### Q398.


#### Q399.


#### Q400.


#### Q401.


#### Q402.


#### Q403.


#### Q404.


#### Q405.


#### Q406.


#### Q407.


#### Q408.


#### Q409.


#### Q410.


#### Q411.


#### Q412.


#### Q413.


#### Q414.


#### Q415.


#### Q416.


#### Q417.


#### Q418.


#### Q419.


#### Q420.


#### Q421.


#### Q422.


#### Q423.


#### Q424.


#### Q425.


#### Q426.


#### Q427.


#### Q428.


#### Q429.


#### Q430.


#### Q431.


#### Q432.


#### Q433.


#### Q434.


#### Q435.


#### Q436.


#### Q437.


#### Q438.


#### Q439.


#### Q440.


#### Q441.


#### Q442.


#### Q443.


#### Q444.


#### Q445.


#### Q446.


#### Q447.


#### Q448.


#### Q449.


#### Q450.


#### Q451.


#### Q452.


#### Q453.


#### Q454.


#### Q455.


#### Q456.


#### Q457.


#### Q458.


#### Q459.


#### Q460.


#### Q461.


#### Q462.


#### Q463.


#### Q464.


#### Q465.


#### Q466.


#### Q467.


#### Q468.


#### Q469.


#### Q470.


#### Q471.


#### Q472.


#### Q473.


#### Q474.


#### Q475.


#### Q476.


#### Q477.


#### Q478.


#### Q479.


#### Q480.


#### Q481.


#### Q482.


#### Q483.


#### Q484.


#### Q485.


#### Q486.


#### Q487.


#### Q488.


#### Q489.


#### Q490.


#### Q491.


#### Q492.


#### Q493.


#### Q494.


#### Q495.


#### Q496.


#### Q497.


#### Q498.


#### Q499.


#### Q500.


